import * as XLSX from 'xlsx';
import { jsPDF } from 'jspdf';
import autoTable from 'jspdf-autotable';
import * as pdfjsLib from 'pdfjs-dist';
import { StudentData, SubjectMark, ParsingStats } from '../types';

// --- CONSTANTS ---
const PASS_MARK = 35;
const REGEX_REGNO = /\b\d{6,}\b/; // Matches sequence of 6 or more digits

// Configure PDF Worker
pdfjsLib.GlobalWorkerOptions.workerSrc = `https://unpkg.com/pdfjs-dist@${pdfjsLib.version}/build/pdf.worker.min.mjs`;

// --- PUBLIC API ---

export const mockData = (): { data: StudentData[], stats: ParsingStats } => {
    const mockStudents: StudentData[] = [];
    const depts = ['CSE', 'ECE', 'MECH', 'CIVIL'];
    
    for(let i=0; i < 50; i++) {
        const regNo = `5122${Math.floor(Math.random() * 100000).toString().padStart(6, '0')}`;
        const subjects: SubjectMark[] = [];
        let hasFail = false;
        let absents = 0;
        let total = 0;

        // Mock subjects with real-looking codes
        const subCodes = ['CS301 (Maths)', 'CS302 (DS)', 'CS303 (DPSD)', 'CS304 (OOPs)', 'CS305 (English)'];

        subCodes.forEach(sub => {
            const isAbsent = Math.random() > 0.95;
            let mark: string | number = Math.floor(Math.random() * 65) + 35;
            let status: SubjectMark['status'] = 'PASS';

            if (isAbsent) {
                mark = 'AB';
                status = 'ABSENT';
                absents++;
                hasFail = true;
            } else {
                 // 10% chance to fail
                if(Math.random() > 0.9) {
                    mark = Math.floor(Math.random() * 34);
                    status = 'FAIL';
                    hasFail = true;
                }
                total += Number(mark);
            }

            subjects.push({
                subject: sub,
                mark,
                status,
                color: status === 'PASS' ? '#22c55e' : (status === 'FAIL' ? '#ef4444' : '#94a3b8')
            });
        });

        mockStudents.push({
            regNo,
            name: `Student ${i + 1}`,
            dept: depts[Math.floor(Math.random() * depts.length)],
            subjects,
            totalMarks: total,
            resultStatus: hasFail ? 'FAIL' : 'PASS',
            absentCount: absents
        });
    }

    return {
        data: mockStudents,
        stats: calculateStats(mockStudents)
    };
};

export const processFile = async (file: File): Promise<{ data: StudentData[], stats: ParsingStats }> => {
    const extension = file.name.split('.').pop()?.toLowerCase();
    let rawData: any[] = [];

    if (extension === 'csv' || extension === 'xlsx' || extension === 'xls') {
        rawData = await parseExcel(file);
    } else if (extension === 'pdf') {
        rawData = await parsePDF(file);
    } else {
        throw new Error('Unsupported file format');
    }

    const processedData = normalizeData(rawData);
    if (processedData.length === 0) {
        throw new Error('No student records found. Check the file format.');
    }

    return {
        data: processedData,
        stats: calculateStats(processedData)
    };
};

export const generateStudentPDF = (student: StudentData) => {
    const doc = new jsPDF();
    
    // Header
    doc.setFillColor(15, 23, 42); // Dark Blue
    doc.rect(0, 0, 210, 40, 'F');
    
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(22);
    doc.text('RESULT REPORT', 105, 20, { align: 'center' });
    doc.setFontSize(10);
    doc.text('Generated by SKP Grade Analyzer', 105, 30, { align: 'center' });

    // Student Info
    doc.setTextColor(0, 0, 0);
    doc.setFontSize(12);
    
    let yPos = 55;
    doc.text(`Register No: ${student.regNo}`, 14, yPos);
    doc.text(`Name: ${student.name}`, 14, yPos + 8);
    doc.text(`Department: ${student.dept}`, 14, yPos + 16);

    const statusColor = student.resultStatus === 'PASS' ? [34, 197, 94] : [239, 68, 68];
    doc.setTextColor(statusColor[0], statusColor[1], statusColor[2]);
    doc.setFont('helvetica', 'bold');
    doc.text(`Overall Result: ${student.resultStatus}`, 150, yPos + 8);
    doc.setFont('helvetica', 'normal');

    // Marks Table
    const tableBody = student.subjects.map(sub => [
        sub.subject,
        sub.mark,
        sub.status
    ]);

    autoTable(doc, {
        startY: yPos + 25,
        head: [['Subject', 'Marks', 'Status']],
        body: tableBody,
        theme: 'grid',
        headStyles: { fillColor: [15, 23, 42], textColor: 255 },
        didParseCell: (data) => {
            if (data.section === 'body' && data.column.index === 2) {
                const status = data.cell.raw;
                if (status === 'PASS') data.cell.styles.textColor = [34, 197, 94];
                else if (status === 'FAIL') data.cell.styles.textColor = [239, 68, 68];
                else data.cell.styles.textColor = [148, 163, 184];
            }
        }
    });

    // Footer Summary
    const finalY = (doc as any).lastAutoTable.finalY + 20;
    doc.setTextColor(80, 80, 80);
    doc.setFontSize(10);
    doc.text(`Total Marks: ${student.totalMarks}`, 14, finalY);
    doc.text(`Backlogs/Absents: ${student.subjects.filter(s => s.status !== 'PASS').length}`, 14, finalY + 6);
    
    doc.save(`${student.regNo}_Report.pdf`);
};

export const generateAllReports = async (students: StudentData[]) => {
    for (const student of students) {
        generateStudentPDF(student);
        await new Promise(resolve => setTimeout(resolve, 300));
    }
};

export const generateMasterJSON = (students: StudentData[]) => {
    const jsonString = JSON.stringify(students, null, 2);
    const blob = new Blob([jsonString], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = "master_result_data.json";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
};

// --- INTERNAL HELPERS ---

async function parseExcel(file: File): Promise<any[]> {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = new Uint8Array(e.target?.result as ArrayBuffer);
                const workbook = XLSX.read(data, { type: 'array' });
                const sheetName = workbook.SheetNames[0];
                const sheet = workbook.Sheets[sheetName];
                const jsonData = XLSX.utils.sheet_to_json(sheet);
                resolve(jsonData);
            } catch (err) {
                reject(err);
            }
        };
        reader.onerror = (err) => reject(err);
        reader.readAsArrayBuffer(file);
    });
}

async function parsePDF(file: File): Promise<any[]> {
    const arrayBuffer = await file.arrayBuffer();
    const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
    const rawRows: any[] = [];
    let detectedHeaders: string[] = [];

    for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        const textContent = await page.getTextContent();
        const items = textContent.items as any[];
        const lineMap: Record<number, any[]> = {};

        // 1. Group items by Y coordinate
        items.forEach(item => {
            if (item.transform && item.str) {
                // Round Y to handle slight misalignments
                const y = Math.round(item.transform[5]); 
                if (!lineMap[y]) lineMap[y] = [];
                lineMap[y].push({ str: item.str.trim(), x: item.transform[4] });
            }
        });

        // 2. Sort lines from Top to Bottom
        const sortedY = Object.keys(lineMap).map(Number).sort((a, b) => b - a);

        // 3. Detect Headers (if not already found)
        if (detectedHeaders.length === 0) {
            for (const y of sortedY) {
                // Sort text items left to right
                const lineItems = lineMap[y].sort((a, b) => a.x - b.x);
                const lineText = lineItems.map(i => i.str).join(' ').trim();

                // Heuristic: Row has "Reg" & "No", but is NOT a student data row
                if (/Reg/i.test(lineText) && /No/i.test(lineText) && !REGEX_REGNO.test(lineText)) {
                    // Filter out common columns to isolate Subject names
                    const rawTokens = lineItems.map(i => i.str).filter(s => s.length > 0);
                    
                    // STRICT FILTER: Exclude "Name of the Student", "S.No", etc.
                    // But KEEP "ATTN", "No pass", "No fail" if present, because they contain values that look like marks
                    // and we need to map them to keys so we can safely IGNORE them later.
                    const potentialSubjects = rawTokens.filter(t => {
                        // Normalize: remove spaces, dots, and lowercase
                        const cleanT = t.replace(/[\.\s]/g, '').toLowerCase();
                        // Regex to exclude: RegNo, Name, SNo, Dept, etc.
                        // "nameofthestudent" is specifically added here to prevent it being caught as a subject header
                        return !/^(regno|name|nameofthestudent|sno|register|number|student|dept|department|result|roll|no)$/.test(cleanT);
                    });
                    
                    if (potentialSubjects.length > 0) {
                        detectedHeaders = potentialSubjects;
                        console.log('Detected Headers:', detectedHeaders);
                    }
                }
            }
        }

        // 4. Parse Data Rows
        sortedY.forEach(y => {
            const lineItems = lineMap[y].sort((a, b) => a.x - b.x);
            const lineText = lineItems.map(i => i.str).join(' ').trim();

            if (REGEX_REGNO.test(lineText)) {
                const parsed = parsePDFLineToObj(lineText, detectedHeaders);
                if (parsed) rawRows.push(parsed);
            }
        });
    }
    return rawRows;
}

function parsePDFLineToObj(line: string, headers: string[]): any {
    const tokens = line.split(/\s+/);
    const regNoIndex = tokens.findIndex(t => REGEX_REGNO.test(t));
    
    if (regNoIndex === -1) return null;

    const regNo = tokens[regNoIndex];
    
    // Extract Marks (scan from end backwards)
    // Matches numbers, AB, F, PASS, FAIL, A, etc.
    const marks: string[] = [];
    let lastTokenIdx = tokens.length - 1;
    
    while(lastTokenIdx > regNoIndex) {
        const t = tokens[lastTokenIdx];
        // Is this a grade/mark?
        if (/^(\d+|AB|A|F|PASS|FAIL|ABS|-)$/i.test(t)) {
            marks.unshift(t); // Add to front since we are scanning backwards
            lastTokenIdx--;
        } else {
            // Hit the Name?
            break;
        }
    }

    // Extract Name (Between RegNo and Marks)
    const nameParts = tokens.slice(regNoIndex + 1, lastTokenIdx + 1);
    const name = nameParts.join(" ") || "Unknown";

    // Construct Object
    const result: any = {
        "RegNo": regNo,
        "Name": name
    };

    // Map Marks to Headers
    marks.forEach((mark, idx) => {
        const subjectName = (headers && headers[idx]) ? headers[idx] : `Subject_${idx + 1}`;
        result[subjectName] = mark;
    });

    return result;
}

function normalizeData(rawData: any[]): StudentData[] {
    return rawData.map(row => {
        // 1. Identify RegNo
        let regNo = '';
        let name = 'Student';
        let dept = 'General';
        
        // Find key matching RegNo pattern or named RegNo
        if (row['RegNo']) regNo = row['RegNo'];
        else {
            for (const [key, val] of Object.entries(row)) {
                if (REGEX_REGNO.test(String(val))) {
                    regNo = String(val);
                    break;
                }
            }
        }

        if (!regNo) return null;

        // 2. Identify Name
        if (row['Name']) name = row['Name'];
        else {
            const nameKey = Object.keys(row).find(k => /name/i.test(k));
            if (nameKey) name = String(row[nameKey]);
        }

        // 3. Extract Marks
        const subjects: SubjectMark[] = [];
        let total = 0;
        let absents = 0;
        let hasFail = false;

        // Updated list of keys to ignore based on user requirements
        // We ignore "attn", "nopass", "nofail" here.
        // Note: "attn%" will normalize to "attn" via strippedKey logic if not careful, 
        // but we explicitly list variants to be safe.
        const ignoredKeys = [
            'reg', 'no', 'register', 'name', 'nameofthestudent', 'sno', 'sl', 'dept', 'department', 'result', 'status', 'total',
            'attn', 'attn%', 'nopass', 'nofail', 'pass', 'fail'
        ];

        Object.entries(row).forEach(([key, val]) => {
            const lowerKey = key.toLowerCase();
            const strippedKey = lowerKey.replace(/[^a-z0-9]/g, '');
            
            // Skip identity and unwanted columns
            if (ignoredKeys.some(ik => lowerKey === ik || strippedKey === ik)) return;
            // Also skip if key is exactly RegNo or Name which might have slipped through
            if(key === 'RegNo' || key === 'Name') return;

            let markVal = String(val).trim().toUpperCase();
            let markNum = 0;
            let status: SubjectMark['status'] = 'PASS';

            // Handle Absents
            if (['AB', 'A', 'ABS', 'ABSENT', '-'].includes(markVal)) {
                markVal = 'AB';
                status = 'ABSENT';
                absents++;
                hasFail = true;
            } 
            // Handle Numeric
            else if (!isNaN(Number(markVal))) {
                markNum = Number(markVal);
                if (markNum < PASS_MARK) {
                    status = 'FAIL';
                    hasFail = true;
                }
                total += markNum;
            } else {
                // Skip text columns that aren't marks
                return;
            }

            subjects.push({
                subject: key.replace(/_/g, ' '),
                mark: markVal,
                status: status,
                color: status === 'PASS' ? '#22c55e' : (status === 'FAIL' ? '#ef4444' : '#94a3b8')
            });
        });

        if (subjects.length === 0) return null;

        return {
            regNo,
            name,
            dept,
            subjects,
            totalMarks: total,
            resultStatus: hasFail ? 'FAIL' : 'PASS',
            absentCount: absents
        };
    }).filter((s): s is StudentData => s !== null);
}

function calculateStats(students: StudentData[]): ParsingStats {
    const totalStudents = students.length;
    const totalPassed = students.filter(s => s.resultStatus === 'PASS').length;
    const totalFailed = totalStudents - totalPassed;
    
    const grandTotal = students.reduce((acc, curr) => acc + curr.totalMarks, 0);
    const subjectCount = students[0]?.subjects.length || 1; 
    const averageScore = totalStudents > 0 ? (grandTotal / (totalStudents * subjectCount)) : 0;

    return {
        totalStudents,
        totalPassed,
        totalFailed,
        averageScore
    };
}